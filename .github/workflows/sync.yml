name: sync

on:
  schedule:
    - cron: "57 2 * * *"
  workflow_dispatch:
    inputs:
      debug_with_ssh_key:
        description: 'Public SSH key to use to debug failures'
        required: false

env:
  GIT_CONFIG_PARAMETERS: "'user.name=Git for Windows Build Agent' 'user.email=ci@git-for-windows.build' 'windows.sdk64.path=${{ github.workspace }}' 'windows.sdk32.path=' 'http.sslbackend=schannel' 'core.autocrlf=false' 'checkout.workers=16'"
  HOME: "${{ github.workspace }}\\home\\git-ci"
  MSYSTEM: MSYS

jobs:
  sync:
    if: github.repository_owner == 'git-for-windows' || github.event.inputs.debug_with_ssh_key != ''
    runs-on: windows-latest
    environment: sync
    steps:
      - name: clone git-sdk-arm64
        uses: actions/checkout@v3
        with:
          persist-credentials: true
          token: ${{ secrets.PUSH_TOKEN }}
      - name: clone build-extra
        uses: actions/checkout@v3
        with:
          path: usr\\src\\build-extra
          ref: main
          repository: git-for-windows/build-extra
      - name: Update all Pacman packages
        shell: cmd
        run: |
          @REM Enable extensions
          @REM the `verify other 2>nul` is a trick from the setlocal help
          @VERIFY other 2>nul
          @SETLOCAL enableDelayedExpansion

          @IF ERRORLEVEL 1 (
              @ECHO Unable to enable delayed expansion!
              @EXIT /B 1
          )

          @REM Get the absolute path to the current directory (i.e. the SDK root)
          @FOR /F "delims=" %%I IN ("%~dp0..") do @set git_sdk_root=%%~fI
          @SET PATH=%~dp0\usr\bin;%PATH%

          @REM Set to MSYS mode
          @SET MSYSTEM=MSYS

          @ECHO Run Pacman (First Pass)
          @pacman -Syyu --noconfirm
          @ECHO End of Pacman (First Pass)
          @ECHO ==
          @IF ERRORLEVEL 1 GOTO DIE

          @REM If Pacman updated "core" packages, e.g. the MSYS2 runtime, it stops
          @REM (because Pacman itself depends on the MSYS2 runtime, and continuing would
          @REM result in crashes or hangs). In such a case, we simply need to upgrade
          @REM *again*.
          @REM
          @REM To detect that, we look at Pacman's log and search for the needle
          @REM
          @REM 	[PACMAN] starting <upgrade-type> system upgrade
          @REM
          @REM If the last such line has the upgrade type `full`, we're fine, and do not
          @REM need to run Pacman again. Otherwise we will have to run it again, letting
          @REM it upgrade the non-core packages.
          @REM
          @REM Since this condition is pretty much impossible to determine in a plain
          @REM `.bat` script, we call out to the Bash to search for that needle. The
          @REM actual command looks a bit ugly because there are *two* levels of
          @REM escaping:
          @REM
          @REM - The "outer" one, for CMD, via carets (`^`), for every double
          @REM   quote (`"`), ampersand (`&`) and pipe symbol (`|`).
          @REM
          @REM - The "inner" one, for Bash, via backslashes (`\`), for "inner" double
          @REM   quotes (i.e. *not* for the double quotes enclosing the script snippet
          @REM   that is passed to Bash itself) and for brackets (`[` and `]`).
          @REM
          @REM   The inner double quotes must therefore be escaped twice: `\^"`.
          @REM
          @REM The carets at the end of the line are continuation symbols, to allow for
          @REM specifying a long script snippet on multiple lines.
          @REM
          @REM Also note that `IF ERRORLEVEL 0 GOTO LABEL` jumps to said label when the
          @REM error level is 0 *or higher*, i.e. it would always jump. Not what we want.
          @REM So we *must* make it an "error" when everything is upgraded already.

          @ECHO Find last Upgrade in Pacman.log
          @usr\bin\bash.exe -lc ^" ^
                  needle=\^"$(tail -c 16384 /var/log/pacman.log ^| ^
                             grep '\[PACMAN\] starting .* system upgrade' ^| ^
                             tail -n 1)\^" ^&^& ^
                  test -n \^"$needle\^" ^&^& ^
                  test \^"a$needle\^" = \^"a${needle#*full system upgrade}\^"^"
          @ECHO End of search for full/partial Upgrade indicator in Pacman.log
          @ECHO ==
          @IF ERRORLEVEL 1 GOTO FINISH

          @ECHO "Run Pacman again (Second Pass) to upgrade the remaining (non-core) packages"
          @pacman -Su --noconfirm
          @ECHO "End of Pacman (Second Pass) for (non-core) packages"
          @ECHO ==
          @IF ERRORLEVEL 1 GOTO DIE

          :FINISH
          @ECHO Wrapping up: re-install git-extra
          @pacman -S --noconfirm git-extra
          @ECHO End of re-install of git-extra
          @ECHO ==
          @IF ERRORLEVEL 1 GOTO DIE

          @ECHO All done!
          @EXIT /B 0

          :DIE
          @ECHO Pacman update failed!
          @PAUSE
          @EXIT /B 1
      - name: use git-sdk-arm64's Bash
        run: "usr\\bin\\bash.exe -lc 'cygpath -aw /usr/bin >>$GITHUB_PATH && cygpath -aw /clangarm64/bin >>$GITHUB_PATH'"
      - name: commit & push ARM64 SDK
        shell: bash
        run: |
          set -x &&
          sh -x /usr/src/build-extra/commit-msys2.sh commit &&
          git -C / push origin ${{ github.ref }}
      - name: Debug using tmate
        if: failure() && github.event.inputs.debug_with_ssh_key != ''
        shell: bash
        run: |
          # Install tmate
          pacman -Sy --noconfirm tmate openssh &&

          # Restrict SSH access to the "actor", i.e. the GitHub user who triggered this workflow
          mkdir -p ~/.ssh &&
          echo '${{github.event.inputs.debug_with_ssh_key}}' >~/.ssh/authorized_keys &&

          # Generate an SSH key (needed for tmate)
          echo -e 'y\n' | ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &&

          # Start tmate session
          export CHERE_INVOKING=1 &&
          tmate -S /tmp/tmate.sock -a ~/.ssh/authorized_keys new-session -d &&
          tmate -S /tmp/tmate.sock wait tmate-ready &&

          # Print SSH invocation every 5 seconds, until tmate session has terminated
          while test -e /tmp/tmate.sock
          do
            tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}'
            sleep 5
          done
