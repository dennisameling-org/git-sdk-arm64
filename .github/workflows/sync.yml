name: sync

on:
  schedule:
    - cron: "57 2 * * *"
  workflow_dispatch:
    inputs:
      debug_with_ssh_key:
        description: 'Public SSH key to use to debug failures'
        required: false

env:
  GIT_CONFIG_PARAMETERS: "'user.name=Git for Windows Build Agent' 'user.email=ci@git-for-windows.build' 'windows.sdk64.path=${{ github.workspace }}' 'windows.sdk32.path=' 'http.sslbackend=schannel' 'core.autocrlf=false' 'checkout.workers=16'"
  HOME: "${{ github.workspace }}\\home\\git-ci"
  MSYSTEM: MSYS

jobs:
  sync:
    if: github.repository_owner == 'git-for-windows' || github.event.inputs.debug_with_ssh_key != ''
    runs-on: windows-latest
    environment: sync
    steps:
      - name: clone git-sdk-arm64
        uses: actions/checkout@v3
        with:
          persist-credentials: true
          token: ${{ secrets.PUSH_TOKEN }}
      - name: clone build-extra
        uses: actions/checkout@v3
        with:
          path: usr\\src\\build-extra
          ref: main
          repository: git-for-windows/build-extra
      - name: Update all Pacman packages
        shell: pwsh
        run: |
          $env:PATH = "$(Get-Location)\usr\bin;" + $env:PATH

          # Set to MSYS mode
          $env:MSYSTEM = "MSYS"
          $env:MSYS2_PATH_TYPE = "minimal"

          # Create /var/log/ so that pacman.log is written
          New-Item -ItemType Directory -Path var\log -Force

          echo "Run Pacman (First Pass)"
          bash -lc "pacman -Syyu --overwrite=\* --noconfirm"
          if (!$?) { exit 1 }

          # If Pacman updated "core" packages, e.g. the MSYS2 runtime, it stops
          # (because Pacman itself depends on the MSYS2 runtime, and continuing would
          # result in crashes or hangs). In such a case, we simply need to upgrade
          # *again*.
          #
          # To detect that, we look at Pacman's log and search for the needle
          #
          # 	[PACMAN] starting <upgrade-type> system upgrade
          #
          # If the last such line has the upgrade type `full`, we're fine, and do not
          # need to run Pacman again. Otherwise we will have to run it again, letting
          # it upgrade the non-core packages.

          $type=(
            Get-Content -Tail 64 var\log\pacman.log |
            Select-String -AllMatches -Pattern "\[PACMAN\] starting .* system upgrade" |
            Select -Last 1
          )
          if ($type -Match "full system upgrade") {
            echo "No second pass needed"
          } else {
            echo "Run Pacman again (Second Pass) to upgrade the remaining (non-core) packages"
            bash -lc "pacman -Su --overwrite=\* --noconfirm"
            if (!$?) { exit 1 }
          }

          # Wrapping up: re-install git-extra
          bash -lc "pacman -S --overwrite=\* --noconfirm git-extra"
      - name: use git-sdk-arm64's Bash and Git for Windows' git.exe
        run: "usr\\bin\\bash.exe -lc 'cygpath -aw /usr/bin >>$GITHUB_PATH && cygpath -aw /c/Program\ Files/Git/cmd/ >>$GITHUB_PATH'"
      - name: commit & push ARM64 SDK
        shell: bash
        run: |
          set -x &&
          PATH=/c/Program\ Files/Git/cmd:/usr/bin:$PATH &&
          sh -x /usr/src/build-extra/commit-msys2.sh commit &&
          git push origin ${{ github.ref }}
      - name: use MSYS2 for tmate
        if: failure() && github.event.inputs.debug_with_ssh_key != ''
        run: "usr\\bin\\bash.exe -lc 'cygpath -aw /c/msys64/usr/bin >>$GITHUB_PATH'"
      - name: Debug using tmate
        if: failure() && github.event.inputs.debug_with_ssh_key != ''
        shell: bash
        run: |
          # Install tmate
          pacman -Sy --noconfirm tmate openssh &&

          # Restrict SSH access to the "actor", i.e. the GitHub user who triggered this workflow
          mkdir -p ~/.ssh &&
          echo '${{github.event.inputs.debug_with_ssh_key}}' >~/.ssh/authorized_keys &&

          # Generate an SSH key (needed for tmate)
          echo -e 'y\n' | ssh-keygen -q -t rsa -N '' -f ~/.ssh/id_rsa &&

          # Start tmate session
          export CHERE_INVOKING=1 &&
          tmate -S /tmp/tmate.sock -a ~/.ssh/authorized_keys new-session -d &&
          tmate -S /tmp/tmate.sock wait tmate-ready &&

          # Print SSH invocation every 5 seconds, until tmate session has terminated
          while test -e /tmp/tmate.sock
          do
            tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}'
            sleep 5
          done
